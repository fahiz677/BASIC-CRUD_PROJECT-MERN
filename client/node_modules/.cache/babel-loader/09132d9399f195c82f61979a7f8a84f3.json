{"ast":null,"code":"import _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nimport _toPropertyKey from \"@babel/runtime/helpers/esm/toPropertyKey\";\nimport * as React from 'react';\nimport { useGridApiMethod } from '../../utils/useGridApiMethod';\n/**\n * Implement the Pipeline Pattern\n *\n * More information and detailed example in (TODO add link to technical doc when ready)\n *\n * Some plugins contains custom logic to enrich data provided by other plugins or components.\n * For instance, the row grouping plugin needs to add / remove the grouping columns when the grid columns are updated.\n *\n * =====================================================================================================================\n *\n * The plugin containing the custom logic must use:\n *\n * - `useGridRegisterPipeProcessor` to register their processor.\n *\n * - `apiRef.current.requestPipeProcessorsApplication` to imperatively re-apply a group.\n *   This method should be used in last resort.\n *   Most of the time, the application should be triggered by an update on the deps of the processor.\n *\n * =====================================================================================================================\n *\n * The plugin or component that needs to enrich its data must use:\n *\n * - `apiRef.current.unstable_applyPipeProcessors` to run in chain all the processors of a given group.\n *\n * - `useGridRegisterPipeApplier` to re-apply the whole pipe when requested.\n *   The applier will be called when:\n *   * a processor is registered.\n *   * `apiRef.current.requestPipeProcessorsApplication` is called for the given group.\n */\n\nexport const useGridPipeProcessing = apiRef => {\n  const processorsCache = React.useRef({});\n  const runAppliers = React.useCallback(groupCache => {\n    if (!groupCache) {\n      return;\n    }\n\n    Object.values(groupCache.appliers).forEach(callback => {\n      callback();\n    });\n  }, []);\n  const registerPipeProcessor = React.useCallback((group, id, processor) => {\n    if (!processorsCache.current[group]) {\n      processorsCache.current[group] = {\n        processors: new Map(),\n        appliers: {}\n      };\n    }\n\n    const groupCache = processorsCache.current[group];\n    const oldProcessor = groupCache.processors.get(id);\n\n    if (oldProcessor !== processor) {\n      groupCache.processors.set(id, processor);\n      runAppliers(groupCache);\n    }\n\n    return () => {\n      processorsCache.current[group].processors.set(id, null);\n    };\n  }, [runAppliers]);\n  const registerPipeApplier = React.useCallback((group, id, applier) => {\n    if (!processorsCache.current[group]) {\n      processorsCache.current[group] = {\n        processors: new Map(),\n        appliers: {}\n      };\n    }\n\n    processorsCache.current[group].appliers[id] = applier;\n    return () => {\n      const _appliers = processorsCache.current[group].appliers,\n            otherAppliers = _objectWithoutPropertiesLoose(_appliers, [id].map(_toPropertyKey));\n\n      processorsCache.current[group].appliers = otherAppliers;\n    };\n  }, []);\n  const requestPipeProcessorsApplication = React.useCallback(group => {\n    const groupCache = processorsCache.current[group];\n    runAppliers(groupCache);\n  }, [runAppliers]);\n  const applyPipeProcessors = React.useCallback(function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    const [group, value, context] = args;\n\n    if (!processorsCache.current[group]) {\n      return value;\n    }\n\n    const preProcessors = Array.from(processorsCache.current[group].processors.values());\n    return preProcessors.reduce((acc, preProcessor) => {\n      if (!preProcessor) {\n        return acc;\n      }\n\n      return preProcessor(acc, context);\n    }, value);\n  }, []);\n  const preProcessingPrivateApi = {\n    registerPipeProcessor,\n    registerPipeApplier,\n    requestPipeProcessorsApplication\n  };\n  const preProcessingPublicApi = {\n    unstable_applyPipeProcessors: applyPipeProcessors\n  };\n  useGridApiMethod(apiRef, preProcessingPrivateApi, 'private');\n  useGridApiMethod(apiRef, preProcessingPublicApi, 'public');\n};","map":{"version":3,"names":["_objectWithoutPropertiesLoose","_toPropertyKey","React","useGridApiMethod","useGridPipeProcessing","apiRef","processorsCache","useRef","runAppliers","useCallback","groupCache","Object","values","appliers","forEach","callback","registerPipeProcessor","group","id","processor","current","processors","Map","oldProcessor","get","set","registerPipeApplier","applier","_appliers","otherAppliers","map","requestPipeProcessorsApplication","applyPipeProcessors","args","value","context","preProcessors","Array","from","reduce","acc","preProcessor","preProcessingPrivateApi","preProcessingPublicApi","unstable_applyPipeProcessors"],"sources":["/home/fahiz/Brocamp Works/BASIC-CRUD_PROJECT-MERN/client/node_modules/@mui/x-data-grid/hooks/core/pipeProcessing/useGridPipeProcessing.js"],"sourcesContent":["import _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nimport _toPropertyKey from \"@babel/runtime/helpers/esm/toPropertyKey\";\nimport * as React from 'react';\nimport { useGridApiMethod } from '../../utils/useGridApiMethod';\n/**\n * Implement the Pipeline Pattern\n *\n * More information and detailed example in (TODO add link to technical doc when ready)\n *\n * Some plugins contains custom logic to enrich data provided by other plugins or components.\n * For instance, the row grouping plugin needs to add / remove the grouping columns when the grid columns are updated.\n *\n * =====================================================================================================================\n *\n * The plugin containing the custom logic must use:\n *\n * - `useGridRegisterPipeProcessor` to register their processor.\n *\n * - `apiRef.current.requestPipeProcessorsApplication` to imperatively re-apply a group.\n *   This method should be used in last resort.\n *   Most of the time, the application should be triggered by an update on the deps of the processor.\n *\n * =====================================================================================================================\n *\n * The plugin or component that needs to enrich its data must use:\n *\n * - `apiRef.current.unstable_applyPipeProcessors` to run in chain all the processors of a given group.\n *\n * - `useGridRegisterPipeApplier` to re-apply the whole pipe when requested.\n *   The applier will be called when:\n *   * a processor is registered.\n *   * `apiRef.current.requestPipeProcessorsApplication` is called for the given group.\n */\nexport const useGridPipeProcessing = apiRef => {\n  const processorsCache = React.useRef({});\n  const runAppliers = React.useCallback(groupCache => {\n    if (!groupCache) {\n      return;\n    }\n    Object.values(groupCache.appliers).forEach(callback => {\n      callback();\n    });\n  }, []);\n  const registerPipeProcessor = React.useCallback((group, id, processor) => {\n    if (!processorsCache.current[group]) {\n      processorsCache.current[group] = {\n        processors: new Map(),\n        appliers: {}\n      };\n    }\n    const groupCache = processorsCache.current[group];\n    const oldProcessor = groupCache.processors.get(id);\n    if (oldProcessor !== processor) {\n      groupCache.processors.set(id, processor);\n      runAppliers(groupCache);\n    }\n    return () => {\n      processorsCache.current[group].processors.set(id, null);\n    };\n  }, [runAppliers]);\n  const registerPipeApplier = React.useCallback((group, id, applier) => {\n    if (!processorsCache.current[group]) {\n      processorsCache.current[group] = {\n        processors: new Map(),\n        appliers: {}\n      };\n    }\n    processorsCache.current[group].appliers[id] = applier;\n    return () => {\n      const _appliers = processorsCache.current[group].appliers,\n        otherAppliers = _objectWithoutPropertiesLoose(_appliers, [id].map(_toPropertyKey));\n      processorsCache.current[group].appliers = otherAppliers;\n    };\n  }, []);\n  const requestPipeProcessorsApplication = React.useCallback(group => {\n    const groupCache = processorsCache.current[group];\n    runAppliers(groupCache);\n  }, [runAppliers]);\n  const applyPipeProcessors = React.useCallback((...args) => {\n    const [group, value, context] = args;\n    if (!processorsCache.current[group]) {\n      return value;\n    }\n    const preProcessors = Array.from(processorsCache.current[group].processors.values());\n    return preProcessors.reduce((acc, preProcessor) => {\n      if (!preProcessor) {\n        return acc;\n      }\n      return preProcessor(acc, context);\n    }, value);\n  }, []);\n  const preProcessingPrivateApi = {\n    registerPipeProcessor,\n    registerPipeApplier,\n    requestPipeProcessorsApplication\n  };\n  const preProcessingPublicApi = {\n    unstable_applyPipeProcessors: applyPipeProcessors\n  };\n  useGridApiMethod(apiRef, preProcessingPrivateApi, 'private');\n  useGridApiMethod(apiRef, preProcessingPublicApi, 'public');\n};"],"mappings":"AAAA,OAAOA,6BAAP,MAA0C,yDAA1C;AACA,OAAOC,cAAP,MAA2B,0CAA3B;AACA,OAAO,KAAKC,KAAZ,MAAuB,OAAvB;AACA,SAASC,gBAAT,QAAiC,8BAAjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMC,qBAAqB,GAAGC,MAAM,IAAI;EAC7C,MAAMC,eAAe,GAAGJ,KAAK,CAACK,MAAN,CAAa,EAAb,CAAxB;EACA,MAAMC,WAAW,GAAGN,KAAK,CAACO,WAAN,CAAkBC,UAAU,IAAI;IAClD,IAAI,CAACA,UAAL,EAAiB;MACf;IACD;;IACDC,MAAM,CAACC,MAAP,CAAcF,UAAU,CAACG,QAAzB,EAAmCC,OAAnC,CAA2CC,QAAQ,IAAI;MACrDA,QAAQ;IACT,CAFD;EAGD,CAPmB,EAOjB,EAPiB,CAApB;EAQA,MAAMC,qBAAqB,GAAGd,KAAK,CAACO,WAAN,CAAkB,CAACQ,KAAD,EAAQC,EAAR,EAAYC,SAAZ,KAA0B;IACxE,IAAI,CAACb,eAAe,CAACc,OAAhB,CAAwBH,KAAxB,CAAL,EAAqC;MACnCX,eAAe,CAACc,OAAhB,CAAwBH,KAAxB,IAAiC;QAC/BI,UAAU,EAAE,IAAIC,GAAJ,EADmB;QAE/BT,QAAQ,EAAE;MAFqB,CAAjC;IAID;;IACD,MAAMH,UAAU,GAAGJ,eAAe,CAACc,OAAhB,CAAwBH,KAAxB,CAAnB;IACA,MAAMM,YAAY,GAAGb,UAAU,CAACW,UAAX,CAAsBG,GAAtB,CAA0BN,EAA1B,CAArB;;IACA,IAAIK,YAAY,KAAKJ,SAArB,EAAgC;MAC9BT,UAAU,CAACW,UAAX,CAAsBI,GAAtB,CAA0BP,EAA1B,EAA8BC,SAA9B;MACAX,WAAW,CAACE,UAAD,CAAX;IACD;;IACD,OAAO,MAAM;MACXJ,eAAe,CAACc,OAAhB,CAAwBH,KAAxB,EAA+BI,UAA/B,CAA0CI,GAA1C,CAA8CP,EAA9C,EAAkD,IAAlD;IACD,CAFD;EAGD,CAhB6B,EAgB3B,CAACV,WAAD,CAhB2B,CAA9B;EAiBA,MAAMkB,mBAAmB,GAAGxB,KAAK,CAACO,WAAN,CAAkB,CAACQ,KAAD,EAAQC,EAAR,EAAYS,OAAZ,KAAwB;IACpE,IAAI,CAACrB,eAAe,CAACc,OAAhB,CAAwBH,KAAxB,CAAL,EAAqC;MACnCX,eAAe,CAACc,OAAhB,CAAwBH,KAAxB,IAAiC;QAC/BI,UAAU,EAAE,IAAIC,GAAJ,EADmB;QAE/BT,QAAQ,EAAE;MAFqB,CAAjC;IAID;;IACDP,eAAe,CAACc,OAAhB,CAAwBH,KAAxB,EAA+BJ,QAA/B,CAAwCK,EAAxC,IAA8CS,OAA9C;IACA,OAAO,MAAM;MACX,MAAMC,SAAS,GAAGtB,eAAe,CAACc,OAAhB,CAAwBH,KAAxB,EAA+BJ,QAAjD;MAAA,MACEgB,aAAa,GAAG7B,6BAA6B,CAAC4B,SAAD,EAAY,CAACV,EAAD,EAAKY,GAAL,CAAS7B,cAAT,CAAZ,CAD/C;;MAEAK,eAAe,CAACc,OAAhB,CAAwBH,KAAxB,EAA+BJ,QAA/B,GAA0CgB,aAA1C;IACD,CAJD;EAKD,CAb2B,EAazB,EAbyB,CAA5B;EAcA,MAAME,gCAAgC,GAAG7B,KAAK,CAACO,WAAN,CAAkBQ,KAAK,IAAI;IAClE,MAAMP,UAAU,GAAGJ,eAAe,CAACc,OAAhB,CAAwBH,KAAxB,CAAnB;IACAT,WAAW,CAACE,UAAD,CAAX;EACD,CAHwC,EAGtC,CAACF,WAAD,CAHsC,CAAzC;EAIA,MAAMwB,mBAAmB,GAAG9B,KAAK,CAACO,WAAN,CAAkB,YAAa;IAAA,kCAATwB,IAAS;MAATA,IAAS;IAAA;;IACzD,MAAM,CAAChB,KAAD,EAAQiB,KAAR,EAAeC,OAAf,IAA0BF,IAAhC;;IACA,IAAI,CAAC3B,eAAe,CAACc,OAAhB,CAAwBH,KAAxB,CAAL,EAAqC;MACnC,OAAOiB,KAAP;IACD;;IACD,MAAME,aAAa,GAAGC,KAAK,CAACC,IAAN,CAAWhC,eAAe,CAACc,OAAhB,CAAwBH,KAAxB,EAA+BI,UAA/B,CAA0CT,MAA1C,EAAX,CAAtB;IACA,OAAOwB,aAAa,CAACG,MAAd,CAAqB,CAACC,GAAD,EAAMC,YAAN,KAAuB;MACjD,IAAI,CAACA,YAAL,EAAmB;QACjB,OAAOD,GAAP;MACD;;MACD,OAAOC,YAAY,CAACD,GAAD,EAAML,OAAN,CAAnB;IACD,CALM,EAKJD,KALI,CAAP;EAMD,CAZ2B,EAYzB,EAZyB,CAA5B;EAaA,MAAMQ,uBAAuB,GAAG;IAC9B1B,qBAD8B;IAE9BU,mBAF8B;IAG9BK;EAH8B,CAAhC;EAKA,MAAMY,sBAAsB,GAAG;IAC7BC,4BAA4B,EAAEZ;EADD,CAA/B;EAGA7B,gBAAgB,CAACE,MAAD,EAASqC,uBAAT,EAAkC,SAAlC,CAAhB;EACAvC,gBAAgB,CAACE,MAAD,EAASsC,sBAAT,EAAiC,QAAjC,CAAhB;AACD,CApEM"},"metadata":{},"sourceType":"module"}