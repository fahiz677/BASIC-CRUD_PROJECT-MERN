{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { DEFAULT_GRID_COL_TYPE_KEY } from '../../../colDef';\nimport { gridColumnsStateSelector, gridColumnVisibilityModelSelector } from './gridColumnsSelector';\nimport { clamp } from '../../../utils/utils';\nimport { gridDensityFactorSelector } from '../density/densitySelector';\nimport { gridColumnGroupsHeaderMaxDepthSelector } from '../columnGrouping/gridColumnGroupsSelector';\nexport const COLUMNS_DIMENSION_PROPERTIES = ['maxWidth', 'minWidth', 'width', 'flex'];\n/**\n * Computes width for flex columns.\n * Based on CSS Flexbox specification:\n * https://drafts.csswg.org/css-flexbox-1/#resolve-flexible-lengths\n */\n\nexport function computeFlexColumnsWidth(_ref) {\n  let {\n    initialFreeSpace,\n    totalFlexUnits,\n    flexColumns\n  } = _ref;\n  const flexColumnsLookup = {\n    all: {},\n    frozenFields: [],\n    freeze: field => {\n      const value = flexColumnsLookup.all[field];\n\n      if (value && value.frozen !== true) {\n        flexColumnsLookup.all[field].frozen = true;\n        flexColumnsLookup.frozenFields.push(field);\n      }\n    }\n  }; // Step 5 of https://drafts.csswg.org/css-flexbox-1/#resolve-flexible-lengths\n\n  function loopOverFlexItems() {\n    // 5a: If all the flex items on the line are frozen, free space has been distributed.\n    if (flexColumnsLookup.frozenFields.length === flexColumns.length) {\n      return;\n    }\n\n    const violationsLookup = {\n      min: {},\n      max: {}\n    };\n    let remainingFreeSpace = initialFreeSpace;\n    let flexUnits = totalFlexUnits;\n    let totalViolation = 0; // 5b: Calculate the remaining free space\n\n    flexColumnsLookup.frozenFields.forEach(field => {\n      remainingFreeSpace -= flexColumnsLookup.all[field].computedWidth;\n      flexUnits -= flexColumnsLookup.all[field].flex;\n    });\n\n    for (let i = 0; i < flexColumns.length; i += 1) {\n      const column = flexColumns[i];\n\n      if (flexColumnsLookup.all[column.field] && flexColumnsLookup.all[column.field].frozen === true) {\n        // eslint-disable-next-line no-continue\n        continue;\n      } // 5c: Distribute remaining free space proportional to the flex factors\n\n\n      const widthPerFlexUnit = remainingFreeSpace / flexUnits;\n      let computedWidth = widthPerFlexUnit * column.flex; // 5d: Fix min/max violations\n\n      if (computedWidth < column.minWidth) {\n        totalViolation += column.minWidth - computedWidth;\n        computedWidth = column.minWidth;\n        violationsLookup.min[column.field] = true;\n      } else if (computedWidth > column.maxWidth) {\n        totalViolation += column.maxWidth - computedWidth;\n        computedWidth = column.maxWidth;\n        violationsLookup.max[column.field] = true;\n      }\n\n      flexColumnsLookup.all[column.field] = {\n        frozen: false,\n        computedWidth,\n        flex: column.flex\n      };\n    } // 5e: Freeze over-flexed items\n\n\n    if (totalViolation < 0) {\n      // Freeze all the items with max violations\n      Object.keys(violationsLookup.max).forEach(field => {\n        flexColumnsLookup.freeze(field);\n      });\n    } else if (totalViolation > 0) {\n      // Freeze all the items with min violations\n      Object.keys(violationsLookup.min).forEach(field => {\n        flexColumnsLookup.freeze(field);\n      });\n    } else {\n      // Freeze all items\n      flexColumns.forEach(_ref2 => {\n        let {\n          field\n        } = _ref2;\n        flexColumnsLookup.freeze(field);\n      });\n    } // 5f: Return to the start of this loop\n\n\n    loopOverFlexItems();\n  }\n\n  loopOverFlexItems();\n  return flexColumnsLookup.all;\n}\n/**\n * Compute the `computedWidth` (ie: the width the column should have during rendering) based on the `width` / `flex` / `minWidth` / `maxWidth` properties of `GridColDef`.\n * The columns already have been merged with there `type` default values for `minWidth`, `maxWidth` and `width`, thus the `!` for those properties below.\n * TODO: Unit test this function in depth and only keep basic cases for the whole grid testing.\n * TODO: Improve the `GridColDef` typing to reflect the fact that `minWidth` / `maxWidth` and `width` can't be null after the merge with the `type` default values.\n */\n\nexport const hydrateColumnsWidth = (rawState, viewportInnerWidth) => {\n  const columnsLookup = {};\n  let totalFlexUnits = 0;\n  let widthAllocatedBeforeFlex = 0;\n  const flexColumns = []; // For the non-flex columns, compute their width\n  // For the flex columns, compute there minimum width and how much width must be allocated during the flex allocation\n\n  rawState.orderedFields.forEach(columnField => {\n    const newColumn = _extends({}, rawState.lookup[columnField]);\n\n    if (rawState.columnVisibilityModel[columnField] === false) {\n      newColumn.computedWidth = 0;\n    } else {\n      let computedWidth;\n\n      if (newColumn.flex && newColumn.flex > 0) {\n        totalFlexUnits += newColumn.flex;\n        computedWidth = 0;\n        flexColumns.push(newColumn);\n      } else {\n        computedWidth = clamp(newColumn.width, newColumn.minWidth, newColumn.maxWidth);\n      }\n\n      widthAllocatedBeforeFlex += computedWidth;\n      newColumn.computedWidth = computedWidth;\n    }\n\n    columnsLookup[columnField] = newColumn;\n  });\n  const initialFreeSpace = Math.max(viewportInnerWidth - widthAllocatedBeforeFlex, 0); // Allocate the remaining space to the flex columns\n\n  if (totalFlexUnits > 0 && viewportInnerWidth > 0) {\n    const computedColumnWidths = computeFlexColumnsWidth({\n      initialFreeSpace,\n      totalFlexUnits,\n      flexColumns\n    });\n    Object.keys(computedColumnWidths).forEach(field => {\n      columnsLookup[field].computedWidth = computedColumnWidths[field].computedWidth;\n    });\n  }\n\n  return _extends({}, rawState, {\n    lookup: columnsLookup\n  });\n};\n/**\n * Apply the order and the dimensions of the initial state.\n * The columns not registered in `orderedFields` will be placed after the imported columns.\n */\n\nexport const applyInitialState = (columnsState, initialState) => {\n  if (!initialState) {\n    return columnsState;\n  }\n\n  const {\n    orderedFields = [],\n    dimensions = {}\n  } = initialState;\n  const columnsWithUpdatedDimensions = Object.keys(dimensions);\n\n  if (columnsWithUpdatedDimensions.length === 0 && orderedFields.length === 0) {\n    return columnsState;\n  }\n\n  const orderedFieldsLookup = {};\n  const cleanOrderedFields = [];\n\n  for (let i = 0; i < orderedFields.length; i += 1) {\n    const field = orderedFields[i]; // Ignores the fields in the initialState that matches no field on the current column state\n\n    if (columnsState.lookup[field]) {\n      orderedFieldsLookup[field] = true;\n      cleanOrderedFields.push(field);\n    }\n  }\n\n  const newOrderedFields = cleanOrderedFields.length === 0 ? columnsState.orderedFields : [...cleanOrderedFields, ...columnsState.orderedFields.filter(field => !orderedFieldsLookup[field])];\n\n  const newColumnLookup = _extends({}, columnsState.lookup);\n\n  for (let i = 0; i < columnsWithUpdatedDimensions.length; i += 1) {\n    const field = columnsWithUpdatedDimensions[i];\n\n    const newColDef = _extends({}, newColumnLookup[field], {\n      hasBeenResized: true\n    });\n\n    Object.entries(dimensions[field]).forEach(_ref3 => {\n      let [key, value] = _ref3;\n      newColDef[key] = value === -1 ? Infinity : value;\n    });\n    newColumnLookup[field] = newColDef;\n  }\n\n  const newColumnsState = _extends({}, columnsState, {\n    orderedFields: newOrderedFields,\n    lookup: newColumnLookup\n  });\n\n  return newColumnsState;\n};\nexport const createColumnsState = _ref4 => {\n  let {\n    apiRef,\n    columnsToUpsert,\n    initialState,\n    columnTypes,\n    columnVisibilityModel = gridColumnVisibilityModelSelector(apiRef),\n    keepOnlyColumnsToUpsert = false\n  } = _ref4;\n\n  var _apiRef$current$getRo, _apiRef$current$getRo2, _apiRef$current, _apiRef$current$getRo3;\n\n  const isInsideStateInitializer = !apiRef.current.state.columns;\n  let columnsState;\n\n  if (isInsideStateInitializer) {\n    columnsState = {\n      orderedFields: [],\n      lookup: {},\n      columnVisibilityModel\n    };\n  } else {\n    const currentState = gridColumnsStateSelector(apiRef.current.state);\n    columnsState = {\n      orderedFields: keepOnlyColumnsToUpsert ? [] : [...currentState.orderedFields],\n      lookup: _extends({}, currentState.lookup),\n      // Will be cleaned later if keepOnlyColumnsToUpsert=true\n      columnVisibilityModel\n    };\n  }\n\n  let columnsToKeep = {};\n\n  if (keepOnlyColumnsToUpsert && !isInsideStateInitializer) {\n    columnsToKeep = Object.keys(columnsState.lookup).reduce((acc, key) => _extends({}, acc, {\n      [key]: false\n    }), {});\n  }\n\n  const columnsToUpsertLookup = {};\n  columnsToUpsert.forEach(newColumn => {\n    const {\n      field\n    } = newColumn;\n    columnsToUpsertLookup[field] = true;\n    columnsToKeep[field] = true;\n    let existingState = columnsState.lookup[field];\n\n    if (existingState == null) {\n      let colDef = columnTypes[DEFAULT_GRID_COL_TYPE_KEY];\n\n      if (newColumn.type && columnTypes[newColumn.type]) {\n        colDef = columnTypes[newColumn.type];\n      }\n\n      existingState = _extends({}, colDef, {\n        field,\n        hasBeenResized: false\n      });\n      columnsState.orderedFields.push(field);\n    } else if (keepOnlyColumnsToUpsert) {\n      columnsState.orderedFields.push(field);\n    }\n\n    let hasBeenResized = existingState.hasBeenResized;\n    COLUMNS_DIMENSION_PROPERTIES.forEach(key => {\n      if (newColumn[key] !== undefined) {\n        hasBeenResized = true;\n\n        if (newColumn[key] === -1) {\n          newColumn[key] = Infinity;\n        }\n      }\n    });\n    columnsState.lookup[field] = _extends({}, existingState, newColumn, {\n      hasBeenResized\n    });\n  });\n\n  if (keepOnlyColumnsToUpsert && !isInsideStateInitializer) {\n    Object.keys(columnsState.lookup).forEach(field => {\n      if (!columnsToKeep[field]) {\n        delete columnsState.lookup[field];\n      }\n    });\n  }\n\n  const columnsStateWithPreProcessing = apiRef.current.unstable_applyPipeProcessors('hydrateColumns', columnsState);\n  const columnsStateWithPortableColumns = applyInitialState(columnsStateWithPreProcessing, initialState);\n  return hydrateColumnsWidth(columnsStateWithPortableColumns, (_apiRef$current$getRo = (_apiRef$current$getRo2 = (_apiRef$current = apiRef.current).getRootDimensions) == null ? void 0 : (_apiRef$current$getRo3 = _apiRef$current$getRo2.call(_apiRef$current)) == null ? void 0 : _apiRef$current$getRo3.viewportInnerSize.width) != null ? _apiRef$current$getRo : 0);\n};\nexport const mergeColumnsState = columnsState => state => _extends({}, state, {\n  columns: columnsState\n});\nexport function getFirstNonSpannedColumnToRender(_ref5) {\n  let {\n    firstColumnToRender,\n    apiRef,\n    firstRowToRender,\n    lastRowToRender,\n    visibleRows\n  } = _ref5;\n  let firstNonSpannedColumnToRender = firstColumnToRender;\n\n  for (let i = firstRowToRender; i < lastRowToRender; i += 1) {\n    const row = visibleRows[i];\n\n    if (row) {\n      const rowId = visibleRows[i].id;\n      const cellColSpanInfo = apiRef.current.unstable_getCellColSpanInfo(rowId, firstColumnToRender);\n\n      if (cellColSpanInfo && cellColSpanInfo.spannedByColSpan) {\n        firstNonSpannedColumnToRender = cellColSpanInfo.leftVisibleCellIndex;\n      }\n    }\n  }\n\n  return firstNonSpannedColumnToRender;\n}\nexport function getFirstColumnIndexToRender(_ref6) {\n  let {\n    firstColumnIndex,\n    minColumnIndex,\n    columnBuffer,\n    firstRowToRender,\n    lastRowToRender,\n    apiRef,\n    visibleRows\n  } = _ref6;\n  const initialFirstColumnToRender = Math.max(firstColumnIndex - columnBuffer, minColumnIndex);\n  const firstColumnToRender = getFirstNonSpannedColumnToRender({\n    firstColumnToRender: initialFirstColumnToRender,\n    apiRef,\n    firstRowToRender,\n    lastRowToRender,\n    visibleRows\n  });\n  return firstColumnToRender;\n}\nexport function getTotalHeaderHeight(apiRef, headerHeight) {\n  const densityFactor = gridDensityFactorSelector(apiRef);\n  const maxDepth = gridColumnGroupsHeaderMaxDepthSelector(apiRef);\n  return Math.floor(headerHeight * densityFactor) * ((maxDepth != null ? maxDepth : 0) + 1);\n}","map":{"version":3,"names":["_extends","DEFAULT_GRID_COL_TYPE_KEY","gridColumnsStateSelector","gridColumnVisibilityModelSelector","clamp","gridDensityFactorSelector","gridColumnGroupsHeaderMaxDepthSelector","COLUMNS_DIMENSION_PROPERTIES","computeFlexColumnsWidth","initialFreeSpace","totalFlexUnits","flexColumns","flexColumnsLookup","all","frozenFields","freeze","field","value","frozen","push","loopOverFlexItems","length","violationsLookup","min","max","remainingFreeSpace","flexUnits","totalViolation","forEach","computedWidth","flex","i","column","widthPerFlexUnit","minWidth","maxWidth","Object","keys","hydrateColumnsWidth","rawState","viewportInnerWidth","columnsLookup","widthAllocatedBeforeFlex","orderedFields","columnField","newColumn","lookup","columnVisibilityModel","width","Math","computedColumnWidths","applyInitialState","columnsState","initialState","dimensions","columnsWithUpdatedDimensions","orderedFieldsLookup","cleanOrderedFields","newOrderedFields","filter","newColumnLookup","newColDef","hasBeenResized","entries","key","Infinity","newColumnsState","createColumnsState","apiRef","columnsToUpsert","columnTypes","keepOnlyColumnsToUpsert","_apiRef$current$getRo","_apiRef$current$getRo2","_apiRef$current","_apiRef$current$getRo3","isInsideStateInitializer","current","state","columns","currentState","columnsToKeep","reduce","acc","columnsToUpsertLookup","existingState","colDef","type","undefined","columnsStateWithPreProcessing","unstable_applyPipeProcessors","columnsStateWithPortableColumns","getRootDimensions","call","viewportInnerSize","mergeColumnsState","getFirstNonSpannedColumnToRender","firstColumnToRender","firstRowToRender","lastRowToRender","visibleRows","firstNonSpannedColumnToRender","row","rowId","id","cellColSpanInfo","unstable_getCellColSpanInfo","spannedByColSpan","leftVisibleCellIndex","getFirstColumnIndexToRender","firstColumnIndex","minColumnIndex","columnBuffer","initialFirstColumnToRender","getTotalHeaderHeight","headerHeight","densityFactor","maxDepth","floor"],"sources":["/home/fahiz/Brocamp Works/BASIC-CRUD_PROJECT-MERN/client/node_modules/@mui/x-data-grid/hooks/features/columns/gridColumnsUtils.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { DEFAULT_GRID_COL_TYPE_KEY } from '../../../colDef';\nimport { gridColumnsStateSelector, gridColumnVisibilityModelSelector } from './gridColumnsSelector';\nimport { clamp } from '../../../utils/utils';\nimport { gridDensityFactorSelector } from '../density/densitySelector';\nimport { gridColumnGroupsHeaderMaxDepthSelector } from '../columnGrouping/gridColumnGroupsSelector';\nexport const COLUMNS_DIMENSION_PROPERTIES = ['maxWidth', 'minWidth', 'width', 'flex'];\n/**\n * Computes width for flex columns.\n * Based on CSS Flexbox specification:\n * https://drafts.csswg.org/css-flexbox-1/#resolve-flexible-lengths\n */\nexport function computeFlexColumnsWidth({\n  initialFreeSpace,\n  totalFlexUnits,\n  flexColumns\n}) {\n  const flexColumnsLookup = {\n    all: {},\n    frozenFields: [],\n    freeze: field => {\n      const value = flexColumnsLookup.all[field];\n      if (value && value.frozen !== true) {\n        flexColumnsLookup.all[field].frozen = true;\n        flexColumnsLookup.frozenFields.push(field);\n      }\n    }\n  };\n\n  // Step 5 of https://drafts.csswg.org/css-flexbox-1/#resolve-flexible-lengths\n  function loopOverFlexItems() {\n    // 5a: If all the flex items on the line are frozen, free space has been distributed.\n    if (flexColumnsLookup.frozenFields.length === flexColumns.length) {\n      return;\n    }\n    const violationsLookup = {\n      min: {},\n      max: {}\n    };\n    let remainingFreeSpace = initialFreeSpace;\n    let flexUnits = totalFlexUnits;\n    let totalViolation = 0;\n\n    // 5b: Calculate the remaining free space\n    flexColumnsLookup.frozenFields.forEach(field => {\n      remainingFreeSpace -= flexColumnsLookup.all[field].computedWidth;\n      flexUnits -= flexColumnsLookup.all[field].flex;\n    });\n    for (let i = 0; i < flexColumns.length; i += 1) {\n      const column = flexColumns[i];\n      if (flexColumnsLookup.all[column.field] && flexColumnsLookup.all[column.field].frozen === true) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      // 5c: Distribute remaining free space proportional to the flex factors\n      const widthPerFlexUnit = remainingFreeSpace / flexUnits;\n      let computedWidth = widthPerFlexUnit * column.flex;\n\n      // 5d: Fix min/max violations\n      if (computedWidth < column.minWidth) {\n        totalViolation += column.minWidth - computedWidth;\n        computedWidth = column.minWidth;\n        violationsLookup.min[column.field] = true;\n      } else if (computedWidth > column.maxWidth) {\n        totalViolation += column.maxWidth - computedWidth;\n        computedWidth = column.maxWidth;\n        violationsLookup.max[column.field] = true;\n      }\n      flexColumnsLookup.all[column.field] = {\n        frozen: false,\n        computedWidth,\n        flex: column.flex\n      };\n    }\n\n    // 5e: Freeze over-flexed items\n    if (totalViolation < 0) {\n      // Freeze all the items with max violations\n      Object.keys(violationsLookup.max).forEach(field => {\n        flexColumnsLookup.freeze(field);\n      });\n    } else if (totalViolation > 0) {\n      // Freeze all the items with min violations\n      Object.keys(violationsLookup.min).forEach(field => {\n        flexColumnsLookup.freeze(field);\n      });\n    } else {\n      // Freeze all items\n      flexColumns.forEach(({\n        field\n      }) => {\n        flexColumnsLookup.freeze(field);\n      });\n    }\n\n    // 5f: Return to the start of this loop\n    loopOverFlexItems();\n  }\n  loopOverFlexItems();\n  return flexColumnsLookup.all;\n}\n\n/**\n * Compute the `computedWidth` (ie: the width the column should have during rendering) based on the `width` / `flex` / `minWidth` / `maxWidth` properties of `GridColDef`.\n * The columns already have been merged with there `type` default values for `minWidth`, `maxWidth` and `width`, thus the `!` for those properties below.\n * TODO: Unit test this function in depth and only keep basic cases for the whole grid testing.\n * TODO: Improve the `GridColDef` typing to reflect the fact that `minWidth` / `maxWidth` and `width` can't be null after the merge with the `type` default values.\n */\nexport const hydrateColumnsWidth = (rawState, viewportInnerWidth) => {\n  const columnsLookup = {};\n  let totalFlexUnits = 0;\n  let widthAllocatedBeforeFlex = 0;\n  const flexColumns = [];\n\n  // For the non-flex columns, compute their width\n  // For the flex columns, compute there minimum width and how much width must be allocated during the flex allocation\n  rawState.orderedFields.forEach(columnField => {\n    const newColumn = _extends({}, rawState.lookup[columnField]);\n    if (rawState.columnVisibilityModel[columnField] === false) {\n      newColumn.computedWidth = 0;\n    } else {\n      let computedWidth;\n      if (newColumn.flex && newColumn.flex > 0) {\n        totalFlexUnits += newColumn.flex;\n        computedWidth = 0;\n        flexColumns.push(newColumn);\n      } else {\n        computedWidth = clamp(newColumn.width, newColumn.minWidth, newColumn.maxWidth);\n      }\n      widthAllocatedBeforeFlex += computedWidth;\n      newColumn.computedWidth = computedWidth;\n    }\n    columnsLookup[columnField] = newColumn;\n  });\n  const initialFreeSpace = Math.max(viewportInnerWidth - widthAllocatedBeforeFlex, 0);\n\n  // Allocate the remaining space to the flex columns\n  if (totalFlexUnits > 0 && viewportInnerWidth > 0) {\n    const computedColumnWidths = computeFlexColumnsWidth({\n      initialFreeSpace,\n      totalFlexUnits,\n      flexColumns\n    });\n    Object.keys(computedColumnWidths).forEach(field => {\n      columnsLookup[field].computedWidth = computedColumnWidths[field].computedWidth;\n    });\n  }\n  return _extends({}, rawState, {\n    lookup: columnsLookup\n  });\n};\n\n/**\n * Apply the order and the dimensions of the initial state.\n * The columns not registered in `orderedFields` will be placed after the imported columns.\n */\nexport const applyInitialState = (columnsState, initialState) => {\n  if (!initialState) {\n    return columnsState;\n  }\n  const {\n    orderedFields = [],\n    dimensions = {}\n  } = initialState;\n  const columnsWithUpdatedDimensions = Object.keys(dimensions);\n  if (columnsWithUpdatedDimensions.length === 0 && orderedFields.length === 0) {\n    return columnsState;\n  }\n  const orderedFieldsLookup = {};\n  const cleanOrderedFields = [];\n  for (let i = 0; i < orderedFields.length; i += 1) {\n    const field = orderedFields[i];\n\n    // Ignores the fields in the initialState that matches no field on the current column state\n    if (columnsState.lookup[field]) {\n      orderedFieldsLookup[field] = true;\n      cleanOrderedFields.push(field);\n    }\n  }\n  const newOrderedFields = cleanOrderedFields.length === 0 ? columnsState.orderedFields : [...cleanOrderedFields, ...columnsState.orderedFields.filter(field => !orderedFieldsLookup[field])];\n  const newColumnLookup = _extends({}, columnsState.lookup);\n  for (let i = 0; i < columnsWithUpdatedDimensions.length; i += 1) {\n    const field = columnsWithUpdatedDimensions[i];\n    const newColDef = _extends({}, newColumnLookup[field], {\n      hasBeenResized: true\n    });\n    Object.entries(dimensions[field]).forEach(([key, value]) => {\n      newColDef[key] = value === -1 ? Infinity : value;\n    });\n    newColumnLookup[field] = newColDef;\n  }\n  const newColumnsState = _extends({}, columnsState, {\n    orderedFields: newOrderedFields,\n    lookup: newColumnLookup\n  });\n  return newColumnsState;\n};\nexport const createColumnsState = ({\n  apiRef,\n  columnsToUpsert,\n  initialState,\n  columnTypes,\n  columnVisibilityModel = gridColumnVisibilityModelSelector(apiRef),\n  keepOnlyColumnsToUpsert = false\n}) => {\n  var _apiRef$current$getRo, _apiRef$current$getRo2, _apiRef$current, _apiRef$current$getRo3;\n  const isInsideStateInitializer = !apiRef.current.state.columns;\n  let columnsState;\n  if (isInsideStateInitializer) {\n    columnsState = {\n      orderedFields: [],\n      lookup: {},\n      columnVisibilityModel\n    };\n  } else {\n    const currentState = gridColumnsStateSelector(apiRef.current.state);\n    columnsState = {\n      orderedFields: keepOnlyColumnsToUpsert ? [] : [...currentState.orderedFields],\n      lookup: _extends({}, currentState.lookup),\n      // Will be cleaned later if keepOnlyColumnsToUpsert=true\n      columnVisibilityModel\n    };\n  }\n  let columnsToKeep = {};\n  if (keepOnlyColumnsToUpsert && !isInsideStateInitializer) {\n    columnsToKeep = Object.keys(columnsState.lookup).reduce((acc, key) => _extends({}, acc, {\n      [key]: false\n    }), {});\n  }\n  const columnsToUpsertLookup = {};\n  columnsToUpsert.forEach(newColumn => {\n    const {\n      field\n    } = newColumn;\n    columnsToUpsertLookup[field] = true;\n    columnsToKeep[field] = true;\n    let existingState = columnsState.lookup[field];\n    if (existingState == null) {\n      let colDef = columnTypes[DEFAULT_GRID_COL_TYPE_KEY];\n      if (newColumn.type && columnTypes[newColumn.type]) {\n        colDef = columnTypes[newColumn.type];\n      }\n      existingState = _extends({}, colDef, {\n        field,\n        hasBeenResized: false\n      });\n      columnsState.orderedFields.push(field);\n    } else if (keepOnlyColumnsToUpsert) {\n      columnsState.orderedFields.push(field);\n    }\n    let hasBeenResized = existingState.hasBeenResized;\n    COLUMNS_DIMENSION_PROPERTIES.forEach(key => {\n      if (newColumn[key] !== undefined) {\n        hasBeenResized = true;\n        if (newColumn[key] === -1) {\n          newColumn[key] = Infinity;\n        }\n      }\n    });\n    columnsState.lookup[field] = _extends({}, existingState, newColumn, {\n      hasBeenResized\n    });\n  });\n  if (keepOnlyColumnsToUpsert && !isInsideStateInitializer) {\n    Object.keys(columnsState.lookup).forEach(field => {\n      if (!columnsToKeep[field]) {\n        delete columnsState.lookup[field];\n      }\n    });\n  }\n  const columnsStateWithPreProcessing = apiRef.current.unstable_applyPipeProcessors('hydrateColumns', columnsState);\n  const columnsStateWithPortableColumns = applyInitialState(columnsStateWithPreProcessing, initialState);\n  return hydrateColumnsWidth(columnsStateWithPortableColumns, (_apiRef$current$getRo = (_apiRef$current$getRo2 = (_apiRef$current = apiRef.current).getRootDimensions) == null ? void 0 : (_apiRef$current$getRo3 = _apiRef$current$getRo2.call(_apiRef$current)) == null ? void 0 : _apiRef$current$getRo3.viewportInnerSize.width) != null ? _apiRef$current$getRo : 0);\n};\nexport const mergeColumnsState = columnsState => state => _extends({}, state, {\n  columns: columnsState\n});\nexport function getFirstNonSpannedColumnToRender({\n  firstColumnToRender,\n  apiRef,\n  firstRowToRender,\n  lastRowToRender,\n  visibleRows\n}) {\n  let firstNonSpannedColumnToRender = firstColumnToRender;\n  for (let i = firstRowToRender; i < lastRowToRender; i += 1) {\n    const row = visibleRows[i];\n    if (row) {\n      const rowId = visibleRows[i].id;\n      const cellColSpanInfo = apiRef.current.unstable_getCellColSpanInfo(rowId, firstColumnToRender);\n      if (cellColSpanInfo && cellColSpanInfo.spannedByColSpan) {\n        firstNonSpannedColumnToRender = cellColSpanInfo.leftVisibleCellIndex;\n      }\n    }\n  }\n  return firstNonSpannedColumnToRender;\n}\nexport function getFirstColumnIndexToRender({\n  firstColumnIndex,\n  minColumnIndex,\n  columnBuffer,\n  firstRowToRender,\n  lastRowToRender,\n  apiRef,\n  visibleRows\n}) {\n  const initialFirstColumnToRender = Math.max(firstColumnIndex - columnBuffer, minColumnIndex);\n  const firstColumnToRender = getFirstNonSpannedColumnToRender({\n    firstColumnToRender: initialFirstColumnToRender,\n    apiRef,\n    firstRowToRender,\n    lastRowToRender,\n    visibleRows\n  });\n  return firstColumnToRender;\n}\nexport function getTotalHeaderHeight(apiRef, headerHeight) {\n  const densityFactor = gridDensityFactorSelector(apiRef);\n  const maxDepth = gridColumnGroupsHeaderMaxDepthSelector(apiRef);\n  return Math.floor(headerHeight * densityFactor) * ((maxDepth != null ? maxDepth : 0) + 1);\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}